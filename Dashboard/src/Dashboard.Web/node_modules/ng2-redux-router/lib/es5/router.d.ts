import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/map';
import { ApplicationRef } from '@angular/core';
import { Location } from '@angular/common';
import { Router } from '@angular/router';
import { NgRedux } from 'ng2-redux';
import { Observable } from 'rxjs/Observable';
export declare class NgReduxRouter {
    private router;
    private ngRedux;
    private applicationRef;
    private location;
    private initialized;
    private currentLocation;
    private initialLocation;
    private selectLocationFromState;
    private urlState;
    private urlStateSubscription;
    private reduxSubscription;
    constructor(router: Router, ngRedux: NgRedux<any>, applicationRef: ApplicationRef, location: Location);
    /**
     * Destroys the bindings between ng2-redux and @angular/router.
     * This method unsubscribes from both ng2-redux and @angular router, in case
     * your app needs to tear down the bindings without destroying Angular or Redux
     * at the same time.
     */
    destroy(): void;
    /**
     * Initialize the bindings between ng2-redux and @angular/router
     *
     * This should only be called once for the lifetime of your app, for
     * example in the constructor of your root component.
     *
     *
     * @param {(state: any) => string} selectLocationFromState Optional: If your
     * router state is in a custom location, supply this argument to tell the
     * bindings where to find the router location in the state.
     * @param {Observable<string>} urlState$ Optional: If you have a custom setup
     * when listening to router changes, or use a different router than @angular/router
     * you can supply this argument as an Observable of the current url state.
     */
    initialize(selectLocationFromState?: (state: any) => string, urlState$?: Observable<string>): void;
    private getDefaultUrlStateObservable();
    private getLocationFromStore(useInitial?);
    private listenToRouterChanges();
    private listenToReduxChanges();
}
